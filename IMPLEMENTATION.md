# Goへの完全リプレイス計画

## 現状分析

現在のプロジェクトは、DenoとTypeScriptで構築されていますが、Goに完全にリプレイスする途中です。現状の分析結果は以下の通りです：

### 既存のGo関連ファイル
- `go.mod`: Goモジュール名は「ailab」で、Go 1.24.0を使用
- `go.sum`: 依存関係のチェックサム
- `.cline/build.go`: ルールとモード定義を生成するスクリプト（すでにGoで実装済み）
- `Makefile`: Goのテスト、カバレッジ、リントのためのコマンドが定義されている

### 移行が必要なTypeScriptファイル
1. **コマンドラインツール**
   - `cmd/main.ts`: サブコマンドのホスト
   - `cmd/foo.ts`: サンプルコマンド
   - `cmd/bar.ts`: サンプルコマンド

2. **コア機能**
   - `core/dig.ts`: オブジェクトから指定したパスの値を再帰的に取得する機能
   - `core/flatten.ts`: JSONデータを再帰的に展開し、パス情報に変換する機能

3. **その他のモジュール**
   - `type-predictor/`: JSON データから型を予測するモジュール
   - `tdd-example/`: テストファーストモードとアダプターパターンの実装例
   - `npm-summary/`: npm パッケージのサマリー機能
   - `todo-cli/`: TODOアプリのCLI
   - `todo2/`: TODOアプリの別バージョン
   - `zodcli/`: Zodを使ったCLIツール
   - `scripts/`: 様々なスクリプト

## 移行戦略

Goへの移行は、以下の戦略で進めます：

1. **段階的な移行**
   - 各モジュールを個別に移行し、一度に全てを移行しない
   - 各モジュールの移行後にテストを実行し、機能が正しく動作することを確認

2. **優先順位**
   - コア機能（core/）を最初に移行
   - 次にコマンドラインツール（cmd/）を移行
   - その後、他のモジュールを移行

3. **テストファーストアプローチ**
   - 各モジュールの移行前にGoでテストを作成
   - テストに基づいて実装を行う
   - 既存のTypeScriptのテストケースを参考にする

4. **アダプターパターンの活用**
   - 外部依存を抽象化するためにアダプターパターンを使用
   - テスト時のモック化を容易にする

## ディレクトリ構造

Goへの移行後のディレクトリ構造は以下のようになります：

```
ailab/
├── cmd/                  # コマンドラインツール
│   ├── main.go           # メインエントリーポイント
│   ├── foo.go            # サブコマンド
│   └── bar.go            # サブコマンド
├── internal/             # 内部パッケージ
│   ├── core/             # コア機能
│   │   ├── dig/          # dig機能
│   │   │   ├── dig.go
│   │   │   └── dig_test.go
│   │   └── flatten/      # flatten機能
│   │       ├── flatten.go
│   │       └── flatten_test.go
│   ├── typepredictor/    # 型予測機能
│   │   ├── predictor.go
│   │   └── predictor_test.go
│   └── adapter/          # アダプターパターン実装
│       ├── adapter.go
│       └── adapter_test.go
├── pkg/                  # 公開パッケージ
│   ├── zodcli/           # Zodを使ったCLIツール
│   │   ├── zodcli.go
│   │   └── zodcli_test.go
│   └── todo/             # TODOアプリ
│       ├── todo.go
│       └── todo_test.go
├── .cline/               # CLINEの設定ファイル
│   ├── build.go          # ルールとモード定義を生成するスクリプト
│   ├── rules/            # コーディングルール
│   └── roomodes/         # 実装モード
├── go.mod                # Goモジュール定義
├── go.sum                # 依存関係のチェックサム
├── Makefile              # ビルドスクリプト
└── README.md             # プロジェクト説明
```

## 実装計画

### フェーズ1: 準備と環境設定

1. **プロジェクト構造の作成**
   - 上記のディレクトリ構造を作成
   - 必要なGoパッケージをインストール（testify、yaml.v3など）

2. **ビルドスクリプトの更新**
   - Makefileの更新（必要に応じて）
   - CI/CD設定の更新

### フェーズ2: コア機能の移行

1. **dig機能の移行**
   - `internal/core/dig/dig.go`の作成
   - `internal/core/dig/dig_test.go`の作成
   - 既存のTypeScriptコードを参考に実装
   - テストの実行と検証

2. **flatten機能の移行**
   - `internal/core/flatten/flatten.go`の作成
   - `internal/core/flatten/flatten_test.go`の作成
   - 既存のTypeScriptコードを参考に実装
   - テストの実行と検証

### フェーズ3: コマンドラインツールの移行

1. **コマンドラインフレームワークの選定**
   - cobra、urfave/cliなどのライブラリから選定
   - 既存のcmd-tsライブラリの機能を再現できるものを選ぶ

2. **サブコマンドの実装**
   - `cmd/main.go`の作成
   - `cmd/foo.go`の作成
   - `cmd/bar.go`の作成
   - 既存のTypeScriptコードを参考に実装
   - テストの実行と検証

### フェーズ4: その他のモジュールの移行

1. **type-predictorモジュールの移行**
   - `internal/typepredictor/`ディレクトリの作成
   - 必要なファイルの作成
   - 既存のTypeScriptコードを参考に実装
   - テストの実行と検証

2. **アダプターパターン実装の移行**
   - `internal/adapter/`ディレクトリの作成
   - 必要なファイルの作成
   - 既存のTypeScriptコードを参考に実装
   - テストの実行と検証

3. **その他のモジュールの移行**
   - 優先順位に基づいて順次移行
   - 各モジュールごとにテストを作成し、実装
   - 機能の検証

### フェーズ5: 統合とテスト

1. **全体の統合**
   - 各モジュールの連携テスト
   - エンドツーエンドテスト

2. **パフォーマンステスト**
   - 移行前後のパフォーマンス比較
   - 必要に応じて最適化

3. **ドキュメントの更新**
   - README.mdの更新
   - 各モジュールのドキュメント作成

## 技術的な考慮事項

### 1. 型システムの違い

TypeScriptとGoの型システムには大きな違いがあります：

- **ジェネリクス**: Goのジェネリクスは比較的新しく、TypeScriptほど柔軟ではありません。特に型予測モジュールの移行では、この違いに注意が必要です。
- **インターフェース**: Goのインターフェースは暗黙的に実装されるため、アダプターパターンの実装方法が異なります。
- **構造体タグ**: Goでは構造体タグを使用してメタデータを付与できますが、TypeScriptのデコレータとは異なります。

### 2. エラー処理

TypeScriptではResult型（neverthrow）を使用していますが、Goでは以下のアプローチを検討します：

- **標準的なエラー処理**: `if err != nil`パターン
- **カスタムエラー型**: 詳細なエラー情報を提供するためのカスタム型
- **Result型の実装**: 必要に応じてResult型パターンをGoで実装

### 3. 非同期処理

TypeScriptの非同期処理（Promise、async/await）とGoの並行処理（goroutine、channel）は大きく異なります：

- **goroutineの活用**: 非同期処理をgoroutineに置き換え
- **channelの使用**: データの受け渡しにchannelを使用
- **sync.WaitGroup**: 複数のgoroutineの完了を待機するために使用

### 4. テスト

Goのテストフレームワークは、TypeScriptのものとは異なります：

- **testifyの使用**: アサーションのためにtestifyパッケージを使用
- **テーブル駆動テスト**: Goの標準的なテストパターンを活用
- **サブテスト**: `t.Run()`を使用して関連するテストをグループ化

## リスクと対策

1. **型システムの違いによる機能制限**
   - **リスク**: TypeScriptの高度な型機能をGoで再現できない可能性
   - **対策**: 必要に応じて設計を見直し、Goの型システムに適した実装に変更

2. **パフォーマンスの問題**
   - **リスク**: 移行によりパフォーマンスが低下する可能性
   - **対策**: プロファイリングを行い、ボトルネックを特定して最適化

3. **テストカバレッジの低下**
   - **リスク**: 移行中にテストカバレッジが低下する可能性
   - **対策**: テストファーストアプローチを徹底し、カバレッジ目標を設定

4. **移行の長期化**
   - **リスク**: 移行が予想以上に時間がかかる可能性
   - **対策**: 優先順位を明確にし、段階的に移行を進める

## 結論

Goへの完全リプレイスは、段階的かつ計画的に進める必要があります。各モジュールを個別に移行し、テストを徹底することで、品質を維持しながら移行を進めることができます。また、TypeScriptとGoの言語特性の違いを理解し、適切な設計変更を行うことが重要です。

この計画に基づいて移行を進め、必要に応じて計画を調整していきます。