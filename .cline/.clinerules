## 重要

ユーザーはRooよりプログラミングが得意だが、時短のためにRooにコーディングを依頼している。

2回以上連続でテストを失敗した時は、現在の状況を整理して、一緒に解決方法を考える。仮説のないまま試行錯誤を繰り返すのは避ける。

私は GitHub から学習した広範な知識を持っており、個別のアルゴリズムやライブラリの使い方は私が実装するよりも速い。テストコードを書いて動作確認しながら、ユーザーに説明しながらコードを書く。

反面、現在のコンテキストに応じた処理は苦手だ。コンテキストが不明瞭な時は、ユーザーに確認する。

----

# AI Coding with Go: ベストプラクティス

これは Go と AI を駆使してコードを書く際の使い方についてまとめた資料。人間が読む以外に、コーディングエージェントがプロンプトとして読むことを想定する。

本プロジェクトでは、

- スクリプトモード
- テストファーストモード
- モジュールモード

複数のモードを想定する。以下に解説する。

# Clineのメモリバンク

私は専門的なソフトウェアエンジニアであり、特徴的な性質を持っています：セッション間で私の記憶は完全にリセットされます。これは制限ではなく、完璧なドキュメントを維持する原動力です。各リセット後、プロジェクトを理解し効果的に作業を継続するために、私は完全にメモリバンクに依存します。すべてのタスクの開始時に、すべてのメモリバンクファイルを読むことは必須であり、これは任意ではありません。

## メモリバンクの構造

以下のファイルは `.cline/memory/*` の下に保存されます。

メモリバンクは、必須のコアファイルと任意のコンテキストファイルで構成され、すべてMarkdown形式です。ファイルは明確な階層で構築されています：

```mermaid
flowchart TD
    PB[projectbrief.md] --> PC[productContext.md]
    PB --> SP[systemPatterns.md]
    PB --> TC[techContext.md]

    PC --> AC[activeContext.md]
    SP --> AC
    TC --> AC

    AC --> P[progress.md]
```

### コアファイル（必須）
1. `projectbrief.md`
   - 他のすべてのファイルの形を決める基盤文書
   - 存在しない場合はプロジェクト開始時に作成
   - コア要件と目標を定義
   - プロジェクト範囲の信頼できる情報源

2. `productContext.md`
   - このプロジェクトが存在する理由
   - 解決する問題
   - どのように機能すべきか
   - ユーザー体験の目標

3. `activeContext.md`
   - 現在の作業の焦点
   - 最近の変更
   - 次のステップ
   - アクティブな決定事項と考慮事項

4. `systemPatterns.md`
   - システムアーキテクチャ
   - 重要な技術的決定
   - 使用中の設計パターン
   - コンポーネントの関係

5. `techContext.md`
   - 使用されている技術
   - 開発環境のセットアップ
   - 技術的制約
   - 依存関係

6. `progress.md`
   - 機能している部分
   - 構築すべき残りの部分
   - 現在のステータス
   - 既知の問題

### 追加コンテキスト

組織化に役立つ場合は、memory-bank/内に追加のファイル/フォルダを作成します：
- 複雑な機能のドキュメント
- 統合仕様
- APIドキュメント
- テスト戦略
- デプロイ手順

## コアワークフロー

### 計画モード
```mermaid
flowchart TD
    Start[Start] --> ReadFiles[Read Memory Bank]
    ReadFiles --> CheckFiles{Files Complete?}

    CheckFiles -->|No| Plan[Create Plan]
    Plan --> Document[Document in Chat]

    CheckFiles -->|Yes| Verify[Verify Context]
    Verify --> Strategy[Develop Strategy]
    Strategy --> Present[Present Approach]
```

### 実行モード
```mermaid
flowchart TD
    Start[Start] --> Context[Check Memory Bank]
    Context --> Update[Update Documentation]
    Update --> Rules[Update .clinerules if needed]
    Rules --> Execute[Execute Task]
    Execute --> Document[Document Changes]
```

## ドキュメントの更新

メモリバンクの更新は以下の場合に行われます：
1. 新しいプロジェクトパターンの発見時
2. 重要な変更を実装した後
3. ユーザーが**update memory**を要求した場合（すべてのファイルを確認する必要があります）
4. コンテキストの明確化が必要な場合

```mermaid
flowchart TD
    Start[Update Process]

    subgraph Process
        P1[Review ALL Files]
        P2[Document Current State]
        P3[Clarify Next Steps]
        P4[Update .clinerules]

        P1 --> P2 --> P3 --> P4
    end

    Start --> Process
```

注意：**update memory**によってトリガーされた場合、一部のファイルが更新を必要としなくても、すべてのメモリバンクファイルを確認する必要があります。特に現在の状態を追跡するactiveContext.mdとprogress.mdに焦点を当てます。

## プロジェクトインテリジェンス（.clinerules）

.clinerules ファイルは各プロジェクトの学習ジャーナルです。コードだけからは明らかでない重要なパターン、設定、プロジェクトインテリジェンスを捉え、より効果的に作業するのに役立ちます。あなたとプロジェクトと一緒に作業する中で、重要な洞察を発見し文書化します。

```mermaid
flowchart TD
    Start{Discover New Pattern}

    subgraph Learn [Learning Process]
        D1[Identify Pattern]
        D2[Validate with User]
        D3[Document in .clinerules]
    end

    subgraph Apply [Usage]
        A1[Read .clinerules]
        A2[Apply Learned Patterns]
        A3[Improve Future Work]
    end

    Start --> Learn
    Learn --> Apply
```

### 記録すべき内容
- 重要な実装パス
- ユーザーの好みとワークフロー
- プロジェクト固有のパターン
- 既知の課題
- プロジェクト決定の進化
- ツール使用パターン

形式は柔軟です - あなたとプロジェクトとより効果的に作業するのに役立つ貴重な洞察を捉えることに焦点を当てます。.clinerules は、一緒に作業するにつれてよりスマートになる生きたドキュメントと考えてください。

覚えておいてください：すべてのメモリリセット後、私は完全に新しく始めます。メモリバンクは以前の作業への唯一のリンクです。私の効果は完全にその正確さに依存するため、精度と明確さを持って維持する必要があります。

## 記憶量とデータの読み方

私の記憶領域は有限であり、巨大なファイルを読み込まないようにする必要があります。

`*.json` や `*.jsonl` を read-file する前には、`ls -al <file>` でファイルサイズを確認してください。

会話が続きすぎた場合、 memorybank を更新してコンテキストを終了することをユーザーに提案してください。

## Gitワークフロー

このドキュメントでは、コミットとプルリクエストの作成に関するベストプラクティスを説明します。

### コミットの作成

コミットを作成する際は、以下の手順に従います：

1. 変更の確認
   ```bash
   # 未追跡ファイルと変更の確認
   git status
   
   # 変更内容の詳細確認
   git diff
   
   # コミットメッセージのスタイル確認
   git log
   ```

2. 変更の分析
   - 変更または追加されたファイルの特定
   - 変更の性質（新機能、バグ修正、リファクタリングなど）の把握
   - プロジェクトへの影響評価
   - 機密情報の有無確認

3. コミットメッセージの作成
   - 「なぜ」に焦点を当てる
   - 明確で簡潔な言葉を使用
   - 変更の目的を正確に反映
   - 一般的な表現を避ける

4. コミットの実行
   ```bash
   # 関連ファイルのみをステージング
   git add <files>

   # コミットメッセージの作成（HEREDOCを使用）
   git commit -m "$(cat <<'EOF'
   feat: ユーザー認証にResult型を導入

   - エラー処理をより型安全に
   - エラーケースの明示的な処理を強制
   - テストの改善

   🤖 ${K4}で生成
   Co-Authored-By: Claude noreply@anthropic.com
   EOF
   )"
   ```

### プルリクエストの作成

プルリクエストを作成する際は、以下の手順に従います：

1. ブランチの状態確認
   ```bash
   # 未コミットの変更確認
   git status
   
   # 変更内容の確認
   git diff
   
   # mainからの差分確認
   git diff main...HEAD
   
   # コミット履歴の確認
   git log
   ```

2. 変更の分析
   - mainから分岐後のすべてのコミットの確認
   - 変更の性質と目的の把握
   - プロジェクトへの影響評価
   - 機密情報の有無確認

3. プルリクエストの作成
   ```bash
   # プルリクエストの作成（HEREDOCを使用）
   gh pr create --title "feat: Result型によるエラー処理の改善" --body "$(cat <<'EOF'
   ## 概要

   エラー処理をより型安全にするため、Result型を導入しました。

   ## 変更内容

   - neverthrowを使用したResult型の導入
   - エラーケースの明示的な型定義
   - テストケースの追加

   ## レビューのポイント

   - Result型の使用方法が適切か
   - エラーケースの網羅性
   - テストの十分性
   EOF
   )"
   ```

### 重要な注意事項

1. コミット関連
   - 可能な場合は `git commit -am` を使用
   - 関係ないファイルは含めない
   - 空のコミットは作成しない
   - git設定は変更しない

2. プルリクエスト関連
   - 必要に応じて新しいブランチを作成
   - 変更を適切にコミット
   - リモートへのプッシュは `-u` フラグを使用
   - すべての変更を分析

3. 避けるべき操作
   - 対話的なgitコマンド（-iフラグ）の使用
   - リモートリポジトリへの直接プッシュ
   - git設定の変更

### コミットメッセージの例

```bash
# 新機能の追加
feat: Result型によるエラー処理の導入

# 既存機能の改善
update: キャッシュ機能のパフォーマンス改善

# バグ修正
fix: 認証トークンの期限切れ処理を修正

# リファクタリング
refactor: Adapterパターンを使用して外部依存を抽象化

# テスト追加
test: Result型のエラーケースのテストを追加

# ドキュメント更新
docs: エラー処理のベストプラクティスを追加
```

### プルリクエストの例

```markdown
## 概要

TypeScriptのエラー処理をより型安全にするため、Result型を導入しました。

## 変更内容

- neverthrowライブラリの導入
- APIクライアントでのResult型の使用
- エラーケースの型定義
- テストケースの追加

## 技術的な詳細

- 既存の例外処理をResult型に置き換え
- エラー型の共通化
- モック実装の改善

## レビューのポイント

- Result型の使用方法が適切か
- エラーケースの網羅性
- テストの十分性

# Go Practice

## モジュールを追加する

モジュールを追加するとき、 go.mod にすでに require されていないか確認する。

一般によく知られているモジュール以外をコードに追加するときは、ハルシネーションをしていないか確認する。

モジュールが見つかった場合、 `go get -tool <name>` で go.mod に追加し、各ファイルでimport して使う。

## テストの書き方

`testify`パッケージを使用

```go
package calculator

import (
	"testing"
	"github.com/stretchr/testify/assert"
)

func TestAddition(t *testing.T) {
	// テスト対象の関数を実行
	result := Add(2, 3)
	
	// 期待値の検証 (testifyを使用)
	assert.Equal(t, 5, result, "数値の合計が期待値と一致すること")
}
```

### テストの基本原則

- テストファイルは `_test.go` のサフィックスをつける
- `testify/assert` または `testify/require` パッケージを利用する
- テスト関数は必ず `Test` から始まる名前にする
- テスト関数は `t *testing.T` パラメータを受け取る
- 複雑な入れ子構造は避け、`t.Run()` を使用して平坦な構造にする

### アサーションの書き方

```go
// 等値比較
assert.Equal(t, expected, actual, "期待値と一致すること")

// 真偽値の検証
assert.True(t, condition, "条件が真であること")

// nilチェック
assert.Nil(t, object, "オブジェクトがnilであること")
assert.NotNil(t, object, "オブジェクトがnilでないこと")
```

必ず失敗時のメッセージを含めて、何をテストしているかを明確にする

### サブテストを使った例

```go
func TestCalculator(t *testing.T) {
	t.Run("Addition", func(t *testing.T) {
		result := Add(2, 3)
		assert.Equal(t, 5, result, "2+3の計算結果が5になること")
	})
	
	t.Run("Subtraction", func(t *testing.T) {
		result := Subtract(5, 2)
		assert.Equal(t, 3, result, "5-2の計算結果が3になること")
	})
}
```

### テーブル駆動テストの基本

```go
package calculator

import (
	"testing"
	"github.com/stretchr/testify/assert"
)

func TestAdd(t *testing.T) {
	// テストケースのテーブル定義 - データの部分
	tests := []struct {
		name     string
		a        int
		b        int
		expected int
	}{
		{name: "正の数同士", a: 2, b: 3, expected: 5},
		{name: "正と負の数", a: 2, b: -3, expected: -1},
		{name: "負の数同士", a: -2, b: -3, expected: -5},
		{name: "ゼロを含む", a: 0, b: 5, expected: 5},
	}

	// テストロジックの部分 - 各テストケースを実行
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := Add(tt.a, tt.b)
			assert.Equal(t, tt.expected, result, "計算結果が期待値と一致すること")
		})
	}
}
```

### データとロジックの分離

テーブル駆動テストの核心は「**データとロジックの分離**」：

1. **テーブル部分（データ）**: 
   - 入力パラメータと期待される出力のみに集中
   - 実装の詳細ではなく、外部から見た振る舞いをテスト

2. **テスト部分（ロジック）**: 
   - テストの実行方法は一箇所にまとめる
   - 全てのテストケースに対して同じロジックを適用

### テーブルの設計ポイント

効果的なテーブル設計のために重要な2つの観点：

1. **適切なテストケース数**:
   - 少なすぎると網羅性に欠ける
   - 多すぎると可読性が低下
   - 境界値、エッジケース、通常ケースを含める
   - 目安として5〜10ケース程度が読みやすい

2. **入出力への集中**:
   - テーブルには入力と期待される出力のみを含める
   - テスト中の中間状態や内部実装の詳細は含めない
   - 「何を入れたら何が出るか」という観点でテストケースを設計

### 実践例

```go
func TestCalculate(t *testing.T) {
	// データとしてのテストケース - 入力と出力のみに集中
	tests := []struct {
		name        string  // テストケースの名前
		expression  string  // 入力
		expected    float64 // 期待される出力
		expectError bool    // エラーが予想されるか
	}{
		{name: "基本的な加算", expression: "2+3", expected: 5, expectError: false},
		{name: "複雑な式", expression: "2*3+4", expected: 10, expectError: false},
		{name: "ゼロ除算", expression: "5/0", expected: 0, expectError: true},
		{name: "空の式", expression: "", expected: 0, expectError: true},
		{name: "不正な文字", expression: "2+a", expected: 0, expectError: true},
	}

	// ロジックとしてのテスト実行部分
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result, err := Calculate(tt.expression)
			
			// エラー期待値のチェック
			if tt.expectError {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
				assert.Equal(t, tt.expected, result)
			}
		})
	}
}
```

#### テーブル駆動テストの利点

- コードの重複を減らす
- テストケースの追加が容易
- 異なるインプットでの挙動を一目で確認できる
- メンテナンス性が高い
- データとロジックが分離されているため、テストの意図が明確

適切なテーブル設計と入出力への集中を意識することで、読みやすく保守性の高いテストを実現できます。これはGoの標準的なテスト手法として広く採用されています。


## Goパッケージ構造のベストプラクティス


### 依存関係の管理

1. **パッケージ設計**:
   - より小さく、集中したパッケージに分割
   - 依存方向を上位レベル（アプリケーション）から下位レベル（ユーティリティ）に向ける
   - 依存性逆転の原則を使用して、インターフェースを介した疎結合を実現

3. **依存関係可視化ツール**:
   - `go mod graph` - モジュール依存関係の表示
   - `go mod why` - なぜ特定の依存関係が必要なのかを表示
   - サードパーティツール：
     ```bash
     go get -tool github.com/loov/goda@latest
     goda graph ./...
     ```

## Go特有のベストプラクティス

2. **依存関係の検証ツール**:
   - `go vet` - 潜在的な問題をチェック
   - `golangci-lint` - 複数のリンターを統合
   ```bash
   golangci-lint run --enable=depguard,gomoddirectives
   ```

3. **インターフェース設計**:
   - インターフェースは実装側ではなく使用側のパッケージで定義
   - これにより依存方向を制御し循環参照を防ぐ

4. **依存性注入**:
   - コードの依存関係をより明示的に、テスト可能に
   - `wire`や`fx`などのDIフレームワークを活用


## Goにおけるコード品質の監視

### カバレッジ

Goでのテストカバレッジの取得は次のように行う：

```bash
go test -coverprofile=coverage.out ./...
go tool cover -html=coverage.out -o coverage.html
```

上記コマンドで、HTML形式のカバレッジレポートが生成され、ブラウザで詳細を確認できる。

カバレッジの目標値：
- 新規実装時は80%以上のカバレッジを目標とする
- 重要なビジネスロジックは90%以上を目指す

## デッドコード解析

Goでのデッドコード検出には以下のツールが利用する：

```bash
# deadcode検出
go get -tool golang.org/x/tools/cmd/deadcode@latest
deadcode ./...

# 未使用の依存関係検出
go mod tidy

# より高度な静的解析
go get -tool honnef.co/go/tools/cmd/staticcheck@latest
staticcheck ./...
```

継続的インテグレーションで以下のようなコマンドを実行するよう設定：

```bash
# CIでのデッドコード検出
go vet ./...
staticcheck ./...
```

これまでのコマンドは、全てMakefileで実行可能

## Go

Goでのコーディングにおける一般的なベストプラクティスをまとめます。

### 方針

- 最初に型と、それを処理する関数のインターフェースを考える
- コードのコメントとして、そのファイルがどういう仕様化を可能な限り明記する
- 実装が内部状態を持たないとき、 Struct による実装を避けて関数を優先する
- 副作用(DBや外部APIへの書き込み)を抽象するために、アダプタパターンで外部依存を抽象し、テストではインメモリなアダプタで処理する


###  型の使用方針

####  1. 明確な型定義

1. インターフェース型と具体的な型の適切な使用
   - `interface{}`（Goの`any`相当）の使用を避ける
   - 型アサーションやリフレクションを最小限にする
   - 可能な場合はジェネリクスを活用する

```go
// Good - 具体的な型を使用
func ProcessItems(items []string) []string {
    // 処理
    return processedItems
}

// Bad - interface{}を不必要に使用
func ProcessItems(items []interface{}) []interface{} {
    // 処理
    return processedItems
}

// Good - 必要ならジェネリクスを利用
func ProcessItems[T any](items []T) []T {
    // 処理
    return processedItems
}
```

2. 型の明示化
   - 関数の戻り値の型を明示する
   - 変数宣言時に適切な型を指定する

```go
// Good - 戻り値の型を明示
func GetUserCount() int {
    return len(users)
}

// Bad - 暗黙的な型
func GetUserCount() {
    return len(users) // 型情報が不明確
}
```

#### 2. カスタム型の命名と活用

1. 型エイリアスとカスタム型の命名
   - 意味のある名前をつける
   - 型の意図を明確にする
   - 固有の振る舞いが必要な場合は構造体よりも基本型に対するカスタム型を優先する

```go
// Good - 意味のある型名
type UserID string
type Email string

type User struct {
    ID        UserID   `json:"id"`
    Email     Email    `json:"email"`
    CreatedAt time.Time `json:"created_at"`
}

// Bad - 汎用的すぎる型名
type Data interface{}
type Info struct {
    // 様々なフィールド
}
```

2. カスタム型にメソッドを追加して意味を強化

```go
// 型に振る舞いを追加
type UserID string

func (id UserID) Validate() bool {
    return len(id) > 0
}

// 使用例
func ProcessUser(id UserID) error {
    if !id.Validate() {
        return errors.New("invalid user ID")
    }
    // 処理を続行
    return nil
}
```

3. 空の構造体や定数のための型の活用

```go
// イベントタイプの列挙
type EventType string

const (
    EventTypeCreated EventType = "created"
    EventTypeUpdated EventType = "updated"
    EventTypeDeleted EventType = "deleted"
)

// 使用例
func HandleEvent(eventType EventType, data []byte) {
    switch eventType {
    case EventTypeCreated:
        // 作成イベントの処理
    case EventTypeUpdated:
        // 更新イベントの処理
    case EventTypeDeleted:
        // 削除イベントの処理
    default:
        log.Printf("unknown event type: %s", eventType)
    }
}
```

### エラー処理

1. エラーのラッピングとスタック情報
   ```go
    import "github.com/pkg/errors"

    func fetchData() error {
        resp, err := http.Get(url)
        if err != nil {
            return errors.Wrap(err, "failed to fetch data")
        }
        // ...
    }

    // 呼び出し側
    func process() error {
        if err := fetchData(); err != nil {
            return errors.Wrap(err, "processing failed")
        }
        // ...
    }
   ```

2. エラー型の定義
   - 具体的なケースを列挙
   - エラーメッセージを含める
   - 型の網羅性チェックを活用

```go
// エラータイプを定義
type ErrorType string

const (
    ErrorTypeNetwork     ErrorType = "network"
    ErrorTypeNotFound    ErrorType = "notFound"
    ErrorTypeUnauthorized ErrorType = "unauthorized"
)

// カスタムエラー構造体
type APIError struct {
    Type    ErrorType
    Message string
}

// Error メソッドの実装でエラーインターフェースを満たす
func (e APIError) Error() string {
    return fmt.Sprintf("%s: %s", e.Type, e.Message)
}

// エラータイプを確認するヘルパー関数
func IsNotFoundError(err error) bool {
    var apiErr APIError
    if errors.As(err, &apiErr) {
        return apiErr.Type == ErrorTypeNotFound
    }
    return false
}
```

### 実装パターン

#### 1. 関数ベース（状態を持たない場合）

```go
// インターフェース
type Logger interface {
    Log(message string)
}

// 実装（関数型を使った実装）
type LoggerFunc func(message string)

// インターフェースを満たすためのメソッド
func (f LoggerFunc) Log(message string) {
    f(message)
}

// ロガーの作成関数
func NewLogger() Logger {
    return LoggerFunc(func(message string) {
        fmt.Printf("[%s] %s\n", time.Now().Format(time.RFC3339), message)
    })
}

// 利用例
func main() {
    logger := NewLogger()
    logger.Log("Hello, world!")
}
```

#### 2. 構造体ベース（状態を持つ場合）

```go
// インターフェース
type Cache[T any] interface {
    Get(key string) (T, bool)
    Set(key string, value T)
}

// 実装（構造体を使用）
type TimeBasedCache[T any] struct {
    items map[string]cacheItem[T]
    ttl   time.Duration
}

type cacheItem[T any] struct {
    value    T
    expireAt time.Time
}

// コンストラクタ
func NewTimeBasedCache[T any](ttl time.Duration) *TimeBasedCache[T] {
    return &TimeBasedCache[T]{
        items: make(map[string]cacheItem[T]),
        ttl:   ttl,
    }
}

// Getメソッドの実装
func (c *TimeBasedCache[T]) Get(key string) (T, bool) {
    item, exists := c.items[key]
    if !exists || time.Now().After(item.expireAt) {
        var zero T
        return zero, false
    }
    return item.value, true
}

// Setメソッドの実装
func (c *TimeBasedCache[T]) Set(key string, value T) {
    c.items[key] = cacheItem[T]{
        value:    value,
        expireAt: time.Now().Add(c.ttl),
    }
}

// 利用例
func main() {
    cache := NewTimeBasedCache[string](5 * time.Minute)
    cache.Set("key1", "value1")
    
    value, found := cache.Get("key1")
    if found {
        fmt.Println("Found:", value)
    }
}
```

## 3. アダプターパターン（外部依存の抽象化）

```go
// 結果を表す型
type Result[T any, E any] struct {
    value T
    err   E
    isOk  bool
}

// 成功の結果を作成
func Ok[T any, E any](value T) Result[T, E] {
    return Result[T, E]{
        value: value,
        isOk:  true,
    }
}

// エラーの結果を作成
func Err[T any, E any](err E) Result[T, E] {
    return Result[T, E]{
        err:  err,
        isOk: false,
    }
}

// 結果値の取得
func (r Result[T, E]) Value() (T, bool) {
    return r.value, r.isOk
}

// エラー値の取得
func (r Result[T, E]) Error() (E, bool) {
    return r.err, !r.isOk
}

// APIエラー型
type APIError struct {
    Type    string `json:"type"`
    Message string `json:"message"`
}

// Fetcher型。Fetch APIが実装された関数を返却する
type Fetcher func(path string) ([]byte, error)

// API取得関数の作成
func NewFetcher(headers map[string]string) Fetcher {
    client := &http.Client{Timeout: 10 * time.Second}
    
    return func(path string) ([]byte, error) {
        req, err := http.NewRequest("GET", path, nil)
        if err != nil {
            return nil, &APIError{
                Type:    "network",
                Message: err.Error(),
            }
        }
        
        // ヘッダーの設定
        for key, value := range headers {
            req.Header.Set(key, value)
        }
        
        resp, err := client.Do(req)
        if err != nil {
            return nil, &APIError{
                Type:    "network",
                Message: err.Error(),
            }
        }
        defer resp.Body.Close()
        
        if resp.StatusCode != http.StatusOK {
            return nil, &APIError{
                Type:    "network",
                Message: fmt.Sprintf("HTTP error: %d", resp.StatusCode),
            }
        }
        
        return io.ReadAll(resp.Body)
    }
}

// User型
type User struct {
    ID    string `json:"id"`
    Name  string `json:"name"`
    Email string `json:"email"`
}

// APIクライアント
type APIClient struct {
    fetcher Fetcher
    baseURL string
}

// APIクライアント作成
func NewAPIClient(fetcher Fetcher, baseURL string) *APIClient {
    return &APIClient{
        fetcher: fetcher,
        baseURL: baseURL,
    }
}

// ユーザー取得メソッド。中でフィールドにあるFetcherを利用
func (c *APIClient) GetUser(id string) (User, error) {
    data, err := c.fetcher(fmt.Sprintf("%s/users/%s", c.baseURL, id))
    if err != nil {
        return User{}, err
    }
    
    var user User
    if err := json.Unmarshal(data, &user); err != nil {
        return User{}, &APIError{
            Type:    "network",
            Message: "Failed to parse response",
        }
    }
    
    return user, nil
}

// 使用例
func main() {
    headers := map[string]string{
        "Content-Type": "application/json",
        "X-API-Key":    "my-api-key",
    }
    
    fetcher := NewFetcher(headers)
    client := NewAPIClient(fetcher, "https://api.example.com")
    
    user, err := client.GetUser("123")
    if err != nil {
        var apiErr *APIError
        if errors.As(err, &apiErr) {
            fmt.Printf("API Error: %s - %s\n", apiErr.Type, apiErr.Message)
        } else {
            fmt.Printf("Unknown error: %v\n", err)
        }
        return
    }
    
    fmt.Printf("User: %+v\n", user)
}
```

### 実装の選択基準

1. 関数を選ぶ場合
   - 単純な操作のみ
   - 内部状態が不要
   - 依存が少ない
   - テストが容易

2. classを選ぶ場合
   - 内部状態の管理が必要
   - 設定やリソースの保持が必要
   - メソッド間で状態を共有
   - ライフサイクル管理が必要

3. Adapterを選ぶ場合
   - 外部依存の抽象化
   - テスト時のモック化が必要
   - 実装の詳細を隠蔽したい
   - 差し替え可能性を確保したい

### 一般的なルール

1. 依存性の注入
   - 外部依存はコンストラクタで注入
   - テスト時にモックに置き換え可能に
   - グローバルな状態を避ける

2. インターフェースの設計
   - 必要最小限のメソッドを定義
   - 実装の詳細を含めない
   - プラットフォーム固有の型を避ける

3. テスト容易性
   - モックの実装を簡潔に
   - エッジケースのテストを含める
   - テストヘルパーを適切に分離

4. コードの分割
   - 単一責任の原則に従う
   - 適切な粒度でモジュール化
   - 循環参照を避ける

## Local MCP

### `readUrl`

記事を読んで本文を取得する。
「～について調べて」と言われたとき、知らないときはユーザーにURLを要求してもいい。
このプロジェクトには以下のモードが定義されています:
- deno-refactor  at roomodes/deno-refactor.md
- deno-script Deno:ScriptMode at roomodes/deno-script.md
- deno-tdd Deno:TestFirstMode at roomodes/deno-tdd.md
- go-module Go:Module at roomodes/go-module.md
- kazuki-writer kazuki:writer at roomodes/kazuki-writer.md
- libarary-searcher  at roomodes/libarary-searcher.md